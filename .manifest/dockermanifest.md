# Docker манифест проекта (dev + prod)

Этот документ задаёт правила: **как должны быть устроены Docker-конфигурации** и **как с ними работать** в проекте, чтобы:
- разработка была быстрой (правка кода ≠ rebuild образа),
- сборки были воспроизводимыми,
- production был минимальным и безопасным,
- диск не зарастал мусором (образы/кэш/тома).

> **Важно:** этот файл — **методика/регламент**.  
> Он описывает правила и стандарты; конкретные `Dockerfile`, `docker-compose*.yml`, `Makefile` и `.env.example`
> являются **артефактами проекта** и живут в репозитории по выбранной структуре.

---

## 1) Разделяй dev и prod, не делай rebuild при изменении кода

### 1.1 Разделяй dev и prod
- **Dev-режим** оптимизируем под скорость итераций.
- **Prod-режим** оптимизируем под стабильность, безопасность, минимальный размер.

Нельзя пытаться одним и тем же запуском покрыть всё сразу без разделения режимов.

### 1.2 Разделяй сборку и запуск
- **Порядок запуска** описываем через `healthcheck` + ожидание готовности зависимостей.
- **Порядок сборки** обеспечиваем командами/скриптами (Makefile/CI), а не ожиданиями от `depends_on`.

### 1.3 Не делай rebuild при изменении кода (dev workflow)
- В dev используем **bind mounts** (монтирование исходников).
- В dev используем **watch/reload** (nodemon, cargo-watch, uvicorn --reload и т.п.).
- Rebuild делаем только при изменениях зависимостей или базового окружения.

> Примечание: Dockerfile может содержать dev-stage, но **dev-итерации не должны зависеть от COPY исходников**.
> Основной путь разработки — bind mount.

### 1.4 Обеспечь повторяемость сборок
- Фиксируем версии зависимостей (lock-файлы).
- Базовые образы закрепляем (по tag/желательно digest).
- Конфигурация берётся из env/файлов, а не "магии в контейнере".

### 1.5 Обеспечь кросс-платформенность
- Конфигурация должна работать на Linux, macOS, Windows без правок.
- `.gitattributes` нормализует line endings (eol=lf) для всех текстовых файлов.
- В конфигурационных файлах (compose/Dockerfile/scripts) используем пути с `/`.
- Для bind mounts на macOS/Windows (Docker Desktop) допускается `:cached`, **если поддерживается и даёт прирост**.

---

## 2) Используй base + override схему compose-файлов

### 2.1 Разделяй compose-файлы по режимам
- `docker-compose.base.yml` — общие сервисы и сети (ядро).
- `docker-compose.dev.yml` — dev-override (mounts, debug, ports, watch).
- `docker-compose.prod.yml` — prod-override (минимум портов, без mounts, усиленная безопасность).
- (опц.) `docker-compose.test.yml` — тестовое окружение (изолированное, быстрое).

**Правило:** `base` описывает "что это за сервисы", `override` описывает "как именно мы их запускаем в данном режиме".

### 2.2 Используй profiles для опциональных сервисов
- `monitoring`, `devtools`, `ml`, `debug`, `ci` и т.д.

### 2.3 Создай обязательные файлы
- `.gitattributes` — нормализация line endings
- `.gitignore` — содержит `.env`, но НЕ `.env.example`
- `.env.example` — в Git, идентичен по структуре `.env`
- `.dockerignore` — рядом с каждым Dockerfile
- `Makefile` или task runner — стандартизированные команды

---

## 3) Используй один multi-stage Dockerfile

### 3.1 Используй multi-stage стадии
- `dev` — инструменты разработки (watch/reload/отладка), **без зависимости от COPY исходников для итераций**
- `builder` — сборка/компиляция/установка зависимостей
- `runtime` — минимальный запуск (prod)

> Не создаём отдельные `Dockerfile.dev` и `Dockerfile.prod`. Используем один Dockerfile с multi-stage.

### 3.2 Копируй зависимости до кода
1) копируем файлы зависимостей (`package-lock.json`, `Cargo.lock`, `requirements.txt`, `pyproject.toml`)
2) ставим зависимости
3) копируем исходники (только там, где это требуется для build/runtime)
4) собираем

**Цель:** изменение одного файла в `src/` не должно инвалидировать слой зависимостей.

### 3.3 Используй BuildKit cache mounts
- pip cache
- cargo registry/target
- npm/yarn/pnpm store

### 3.4 Не делай этого в Dockerfile
- Не использовать `:latest` для базовых образов
- Не копировать `.env` или secrets-файлы в образ
- Не устанавливать избыточные системные пакеты
- Не делать dev-итерации зависимыми от `COPY . .` (в dev используем bind mount)

---

## 4) Не храни секреты в репозитории и образе

### 4.1 Используй 12-factor подход
- Конфигурация только через env / конфиг-файлы.
- Один и тот же образ должен запускаться в разных окружениях с разной конфигурацией.

### 4.2 Не храни и не передавай секреты небезопасно
- Не хранить секреты в репозитории.
- Не передавать секреты в командной строке контейнера (видно в `inspect`).
- В prod: предпочтительно file-based secrets (Docker secrets / volume-mounted secret files).
- Минимум: `.env` вне git + строгие права доступа.

### 4.3 Используй единый контракт переменных окружения
Имена env-переменных должны быть одинаковыми в dev/prod/test.
Если нужны разные значения — меняем значения, не ключи.

---

## 5) Закрывай внутренние порты в prod

### 5.1 Ограничивай публикацию портов
- В dev публикуем порты наружу для удобства.
- В prod публикуем только то, что реально нужно пользователям (обычно один reverse-proxy).
- Базы/очереди/мониторинг в prod не должны быть открыты наружу без строгой необходимости.

### 5.2 Разделяй сети на public и internal
- Разделяйте сети: `public` (входящий трафик) и `internal` (межсервисное).
- Для внутренних сервисов достаточно `expose`, а не `ports`.

### 5.3 Не работай под root в prod
- В runtime контейнере желательно работать не под root.
- Файлы с ключами/сертификатами/секретами — с минимальными правами и предсказуемой схемой доставки.

---

## 6) Монтируй dependencies как named volumes

### 6.1 Разделяй данные и кэш
- Данные БД/хранилищ — в устойчивых volume'ах.
- Build/SDK кэши (cargo/pip/node) — отдельно, чтобы ускорять dev, но не путать с данными.

### 6.2 Не ломай права на read-only mounts
Если файл монтируется как read-only, контейнер не должен пытаться менять его права/владельца.
Если нужны права — копируйте внутрь контейнера в writable путь на старте.

### 6.3 Используй named volumes для dependencies в dev
- Dependencies (например, `node_modules`, `target`, `venv`) — **named volumes** (переживают `docker compose down`, ускоряют dev).
- Исходный код — bind mount.
- На macOS/Windows допускается `:cached` **если поддерживается и даёт прирост**.

> Запрещено монтировать dependencies как bind mount (это медленно и ломает права/платформенность).

---

## 7) Определяй healthcheck для критичных зависимостей

### 7.1 Добавляй healthcheck для БД, очередей, кэшей
БД, очередь, кэш, vector store, секрет-хранилище — должны иметь healthcheck.

### 7.2 Жди готовности зависимостей перед запуском
Используйте:
- `healthcheck` + ожидание
- либо `wait-for-it`, `dockerize`, встроенный retry/backoff в приложении

---

## 8) Задавай лимиты ресурсов в prod

### 8.1 В dev — мягкие лимиты
В dev лимиты обычно мягкие, чтобы не мешать отладке.

### 8.2 В prod — строгие лимиты
В prod задавайте:
- лимиты CPU/Memory
- рестарты
- политики логов (ротация)

---

## 9) Пиши логи в stdout/stderr

### 9.1 Не пиши логи в файлы внутри контейнера
- Логи должны уходить в stdout/stderr, без записи в файлы внутри контейнера (если это не специально).
- Для prod — драйвер логов/агент/централизация (ELK/Loki/Vector/Fluent Bit и т.д.).

### 9.2 Защищай доступ к мониторингу
- Мониторинг подключается профилем/override-файлом.
- В prod доступ к мониторингу защищён (VPN/Auth/ACL) и обычно не открыт наружу "как есть".

---

## 10) Стандартизируй команды разработки

### 10.1 Создай единые команды для всех
Проект должен иметь единые команды (Makefile/Taskfile/npm scripts):
- `make dev` — поднять dev окружение
- `make prod` — поднять prod конфигурацию
- `make test` — поднять тестовую инфраструктуру и прогнать тесты
- `make logs` — смотреть логи
- `make ps` — статус
- `make down` — выключить окружение

### 10.2 Обеспечь точечную сборку сервисов
Команды для сборки/перезапуска только одного сервиса должны быть простыми:
- build one
- restart one
- run shell inside

### 10.3 Соблюдай правильный ритм разработки
Типичный день:
- Утро: `make dev` (один раз)
- День: редактирование кода (hot reload, без docker команд)
- Добавил dependency: `make rebuild`
- Вечер: `make down`

**Антипаттерн:** если набираешь `docker build` чаще раза в час — dev workflow организован неправильно.

---

## 11) Настрой команды очистки мусора

### 11.1 Включи очистку в процесс разработки
В проекте должны быть команды очистки:
- **лёгкая очистка** (dangling images)
- **очистка билд-кэша**
- **полная очистка** (осторожно)
- **очистка конкретного проекта** (down + remove-orphans + rmi local)

### 11.2 Очищай регулярно
Рекомендуется:
- лёгкая очистка — ежедневно/по необходимости
- билд-кэш — когда заметно разросся
- полная очистка — после экспериментов/веток/CI-гонок

---

## 12) Проверь минимальный стандарт качества

### Dev must-have
- [ ] bind mounts для исходников
- [ ] watch/reload без rebuild
- [ ] кэш зависимостей (pip/cargo/node) через named volumes или BuildKit cache mounts
- [ ] быстрые команды (make/task scripts)
- [ ] `.gitattributes` с `* text=auto eol=lf`
- [ ] `:cached` для bind mounts на macOS/Windows **если поддерживается и даёт прирост**

### Prod must-have
- [ ] multi-stage Dockerfile (`builder` + `runtime`, опционально `dev`)
- [ ] секреты не в командной строке и не в git
- [ ] закрытые внутренние порты
- [ ] healthchecks/ожидание готовности
- [ ] лимиты ресурсов и политика рестарта
- [ ] централизованные логи/наблюдаемость (опционально)

### Hygiene must-have
- [ ] команды очистки docker-мусора в проекте
- [ ] отсутствие `container_name` (по возможности) для масштабирования/параллельных окружений
- [ ] единый контракт env для всех окружений
- [ ] `.dockerignore` рядом с каждым Dockerfile

---

## 13) Правила для агента при работе с Docker

### 13.1 Создавай новую Docker конфигурацию правильно
- Создать **один** multi-stage Dockerfile (минимум: `builder`, `runtime`, опционально `dev`)
- Убедиться, что dev workflow не зависит от `COPY . .` (основной путь — bind mounts)
- Создать `.dockerignore` (исключить: `node_modules`, `target`, `.git`, `.env`, build artifacts)
- Создать `.gitattributes` с `* text=auto eol=lf`
- Настроить bind mounts в `docker-compose.dev.yml` для исходников
- Настроить dependencies как **named volumes** (не bind mount)
- Использовать `${VAR}` для всех значений в compose
- Создать `.env.example` со всеми переменными

### 13.2 Проверяй существующую конфигурацию
Проверить наличие:
- [ ] multi-stage build в Dockerfile
- [ ] dev workflow без обязательного `COPY . .` (bind mounts + watch/reload)
- [ ] bind mounts для source code в `docker-compose.dev.yml`
- [ ] `.dockerignore`
- [ ] `.gitattributes`
- [ ] `${VAR}` вместо хардкода в compose
- [ ] BuildKit cache mounts где применимо
- [ ] правильный порядок слоёв (deps → install → code)

### 13.3 Соблюдай правила при изменении конфигурации
- НЕ создавай отдельные `Dockerfile.dev` и `Dockerfile.prod` — используй **один Dockerfile** с multi-stage
- НЕ используй хардкод значений в docker-compose (только `${VAR}`)
- НЕ монтируй dependencies как bind mount (только named volumes)
- Сохраняй порядок инструкций для оптимизации кэша
- Используй YAML anchors для устранения дублирования
- Добавляй комментарии для неочевидных решений

### 13.4 Исправляй частые ошибки
- dev-итерации требуют rebuild → проверить bind mounts и watch/reload, убрать зависимость от `COPY . .`
- хардкод в docker-compose → заменить на `${VAR}`
- отсутствует `.dockerignore` → создать
- `:latest` в базовом образе → указать версию/дигест
- отсутствует `.gitattributes` → создать
- дублирующиеся блоки в compose → использовать YAML anchors
- dependencies в bind mount → заменить на named volumes

### 13.5 Используй диагностические вопросы
**Если требуется пересборка при изменении кода:**
- Есть ли bind mount исходников в `docker-compose.dev.yml`?
- Есть ли watch/reload?
- Dev workflow не завязан на `COPY . .`?

**Если медленная работа на macOS/Windows:**
- Используется ли `:cached` (если поддерживается)?
- Dependencies не монтируются bind mount?
- Нет ли лишних файлов в bind mount (проверь `.dockerignore` и состав mounts)?

**Если dependencies устанавливаются каждый раз:**
- Правильный ли порядок в Dockerfile? → COPY deps → RUN install → COPY code
- Используются ли named volumes / BuildKit cache mounts?

**Если shell-скрипты не работают:**
- Есть ли `.gitattributes` с `eol=lf`?

---

## 14) Проверь Definition of Done
Docker-конфигурация считается правильно организованной, если:
- разработчик может править код и сразу видеть результат без пересборки,
- сборка на CI воспроизводима и предсказуема,
- production минимален и не раскрывает внутренние сервисы,
- очистка мусора — штатная команда проекта, а не аварийная мера,
- конфигурация работает на Linux/macOS/Windows без изменений,
- агент может автоматически проверить и исправить типичные ошибки.
