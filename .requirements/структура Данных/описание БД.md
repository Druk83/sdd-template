# Описание БД / структура данных — `<PROJECT_NAME>`

## 0. Назначение

Единый документ для разработки и ревью структуры данных:

* что хранится (объекты данных),
* как связано (ссылки/зависимости/кардинальности),
* как обеспечивается целостность и производительность (ограничения/индексы/правила валидации),
* на что опираемся (требования/обоснования из `docs/**`, проверка по коду/артефактам).

---

## 1. Область применения и источники

### 1.1 Источники требований и решений (только `docs/**`)

В этом документе **все** ссылки на требования/сценарии/решения **обязаны** вести в `docs/**`.

Если `docs/` отсутствует:

* создать задачу в `.tasks/` на публикацию финальных версий в `docs/`;

Перечислить фактические папки проекта; удалить лишнее:

* `docs/requirements/обоснование выбора.md`
* `docs/requirements/предметная область.md`
* `docs/requirements/требования/**`
* `docs/requirements/домены/**`
* `docs/requirements/сценарии/**`
* `docs/requirements/архитектура/**` (если есть)

### 1.2 Источники проверки (код/артефакты)

Перечислить фактический источник структуры данных (проверка «как реализовано»):

* миграции: `<path>`
* модели/схемы ORM/ODM: `<path>`
* DDL/schema: `<path>`
* генерация схемы/дамп: `<command|path>` (если применимо)
* правила валидации NoSQL: `<path>` (если применимо)
* декларации индексов: `<path>` (если отдельно)

---

## 2. Методология описания (задаётся `docs/**/обоснование выбора.md`)

### 2.0 Универсальный принцип (MUST)

Шаблон не фиксирует стек и не предполагает типовые требования.
Единственный источник правил проектирования структуры данных — `docs/**/обоснование выбора.md` + требования/сценарии `docs/**`.

Документ обязан:
- описывать данные через объекты хранения, выбранные проектом (таблицы/коллекции/ключи/серии/топики/объекты и т.д.),
- фиксировать контракты структуры и ссылки на источники,
- быть проверяемым по артефактам реализации.

### 2.1 Выбранная модель представления

Перед заполнением структуры **зафиксировать**, какая модель представления применена (на основании `docs/**/обоснование выбора.md`).

Если `docs/**/обоснование выбора.md` отсутствует:
- создать задачу в `.tasks/` на публикацию финальной версии в `docs/`.

Выбрать и зафиксировать модель(и) (одно или несколько):

* **relational** — таблицы/представления/ограничения/ссылочная целостность.
* **document** — коллекции/структура документов/валидация/индексация/агрегации.
* **time-series** — временные ряды/партиционирование/retention/downsampling/агрегаты.
* **kv** — схема ключей/TTL/атомарные операции/сериализация значений.
* **graph** — типы узлов/рёбер/ограничения/индексы/паттерны запросов.
* **object-storage** — бакеты/объекты/метаданные/lifecycle/retention.
* **event-log/stream** — топики/партиции/схемы/retention/совместимость.
* **hybrid** — карта хранилищ + отдельные спецификации по каждому типу.

Заполнить:
- `модель(и): <...>`
- `единица описания: <table|collection|series|kv-namespace|node/edge|bucket/object|topic|...>`
- `основание: <ссылка на docs/**/обоснование выбора.md#...`

### 2.2 Обязательные срезы описания (универсально)

Независимо от типа хранилища документ обязан содержать:

1. **Перечень объектов данных** (что хранится и где).
2. **Контракты структуры** (поля/типы/схемы/валидаторы/ограничения).
3. **Связи/зависимости** (FK/ссылки/relations/edge types/ключевые зависимости).
4. **Индексация/ключи доступа** (индексы/ключи/партиции/шардинг — если применимо).
5. **Жизненный цикл данных** (retention/TTL/архив/удаление — если задано требованиями).
6. **Проверяемость** (по каким артефактам подтверждается актуальность).

### 2.3 Что меняется в структуре артефактов по типу

Форматы детальных файлов определяются выбранной моделью:

* relational → `tables/<table>.md`, ER-диаграмма, DDL/дамп схемы.
* document → `collections/<collection>.md`, примеры документов, validation/JSON Schema, индексы.
* time-series → `series/<name>.md` (или `tables/**`), политика retention/downsampling, партиции.
* kv → `kv/<namespace>.md`, схема ключей, TTL, форматы значений.
* graph → `graph/<model>.md`, node/edge types, constraints, индексы, паттерны запросов.
* object-storage → `object_storage/<bucket>.md`, метаданные объектов, lifecycle/retention, правила доступа.
* event-log/stream → `streams/<topic>.md`, схема сообщения, совместимость, партиции, retention.

### 2.4 Формат диаграмм (MUST)

Формат диаграмм задаётся `docs/**/обоснование выбора.md`:

- `diagram_format: mermaid` → использовать Mermaid (`.mmd`)
- `diagram_format: plantuml` → использовать PlantUML (`.plantuml`)

Заполнить в финальной спецификации:
- `формат диаграмм: <mermaid|plantuml>`
- `основание: <docs/**/обоснование выбора.md#...>`

Если формат не задан:
- выбрать один формат в проекте (`mermaid` или `plantuml`);
- создать задачу `.tasks/<id>` на фиксацию формата в `docs/**/обоснование выбора.md`.

## 2.4.1 Методология диаграмм по типу хранилища (MUST)

Требование: в финальных артефактах **обязательна** диаграмма(ы), соответствующая выбранной модели(ям) хранения.
Диаграммы делаются в Visual Paradigm (или эквивалентном инструменте) и публикуются как изображение/экспорт + исходник (если применимо).
Формат текстовых диаграмм (Mermaid/PlantUML) определяется в 2.4.

### 2.4.1.1 Базовая (универсальная) диаграмма (обязательна всегда)

**Назначение:** показать карту хранилищ и ключевые потоки/зависимости между доменами/сервисами/Store ID.

- Visual Paradigm: **UML Component Diagram** (по умолчанию)
- Содержимое (минимум):
  - Store ID (DB-01, DB-02…) как компоненты,
  - тип хранилища (`relational/document/time-series/...`),
  - владельцы (сервисы/модули),
  - основные потоки данных/зависимости стрелками,
  - источник истины (пометкой `SoT`) для критичных данных.

Публикация:
- `docs/requirements/структура Данных/diagram.mmd` **или** `diagram.plantuml` (в зависимости от 2.4)
  + при наличии VP — экспорт изображения (например `diagram.svg`/`diagram.png`) рядом (опционально).

### 2.4.1.2 Типовые диаграммы по модели хранения (обязательны по факту наличия типа)

Если выбран тип хранилища, ниже указано, какая диаграмма является типовой и что на ней обязано быть.

#### (A) relational → ERD (обязательна)
- Visual Paradigm: **Entity Relationship Diagram (ERD)**
- Что показываем:
  - таблицы, PK/FK, кардинальности, таблицы-связки M:N,
  - ключевые ограничения (UNIQUE/CHECK — пометками),
  - критичные индексы (пометками).
- Исходник для авто-сборки ER:
  - **обязателен** `docs/requirements/структура Данных/tables/erd.dbml` (dbdiagram.io).
  - ERD в VP сверяется с `erd.dbml` и карточками `tables/*.md`.

#### (B) document → UML Class Diagram (вместо ERD) (обязательна)
- Visual Paradigm: **UML Class Diagram**
- Что показываем:
  - коллекции как классы (или пакеты + классы),
  - “shape” документа: ключевые поля и вложенные поддокументы (верхний уровень + важные вложенности),
  - связи между коллекциями как ассоциации:
    - `embedded` (встроено в документ),
    - `reference` (по id/ссылке),
  - индексы/уникальность/валидация — как notes/constraints.
- Важно:
  - FK/ON DELETE для document **не используются** как методология.

#### (C) time-series → UML Component Diagram (обязательна)
- Visual Paradigm: **UML Component Diagram**
- Что показываем:
  - источники → raw series → агрегаты/downsampling → потребители,
  - retention/политики хранения (notes),
  - ключ серии + время (notes),
  - правила дедупликации/идемпотентности (если есть).

#### (D) kv → UML Component Diagram (обязательна)
- Visual Paradigm: **UML Component Diagram**
- Что показываем:
  - namespaces (логические блоки ключей),
  - шаблоны ключей и TTL (notes),
  - назначение (cache/idempotency/locks),
  - зависимости сервисов, которые читают/пишут ключи.

#### (E) graph → UML Class Diagram (обязательна)
- Visual Paradigm: **UML Class Diagram**
- Что показываем:
  - node types как классы,
  - edge types как связи/ассоциации с подписями,
  - обязательные свойства, индексы/constraints (notes),
  - 1–3 ключевых traversal-паттерна (notes/отдельный блок).

#### (F) object-storage → UML Component Diagram (обязательна)
- Visual Paradigm: **UML Component Diagram**
- Что показываем:
  - buckets (как компоненты/подкомпоненты),
  - схему ключей объектов (notes),
  - метаданные (где живут: в объекте/в БД),
  - lifecycle/retention, правила доступа.

#### (G) event-log/stream → UML Component Diagram (обязательна)
- Visual Paradigm: **UML Component Diagram**
- Что показываем:
  - topics/streams как компоненты,
  - producers/consumers,
  - ключ партиционирования, retention (notes),
  - ссылка на схему сообщения (карточка `streams/<topic>.md`).

#### (H) hybrid → 1 базовая + типовые по каждому используемому типу (обязательна)
- Visual Paradigm:
  - базовая: UML Component Diagram (Store map)
  - далее: ERD/Class/Component по каждому типу из (A)-(G)

### 2.4.1.3 Правило публикации диаграмм (MUST)

- В финальной документации должна быть:
  - базовая диаграмма (2.4.1.1) всегда,
  - типовая диаграмма для каждого фактически используемого типа (2.4.1.2).
- Если типовая диаграмма временно отсутствует:
  - статус `draft` в `docs/requirements/структура Данных/описание БД.md`,
  - задача `.tasks/<id>` на создание/дополнение диаграммы.

## 2.5 Правила проектирования по умолчанию (MUST)
> Эти правила применяются, если в `docs/**/обоснование выбора.md` не задано иное.
> Любое отклонение от правил ниже должно иметь ссылку на `docs/**` и (при необходимости) `.tasks/<id>`.

### 2.5.1 relational (OLTP) — 3НФ по умолчанию (MUST)
Если выбран `relational` и нет отдельной методологии в `docs/**/обоснование выбора.md`, то логическая модель проектируется в 3НФ:

- 1 сущность = 1 таблица. Смешивание разных сущностей в одной таблице запрещено.
- Каждый неключевой атрибут зависит только от PK и не зависит транзитивно от других неключевых атрибутов.
- M:N связи реализуются только через таблицу-связку.
- Повторяющиеся группы/массивы в колонках запрещены; для множественных значений — отдельная таблица/связка.
- Справочники/enum-значения, используемые в нескольких местах или подлежащие изменению, выносятся в отдельные таблицы.
- Денормализация (дублирование данных, предвычисленные поля, wide tables) запрещена без требования производительности и обоснования в `docs/**`.
- JSON/ARRAY допускаются только как "контейнер вторичных атрибутов" при явном обосновании; основная доменная модель — через связи.
- PK:
  - допускается surrogate (uuid/bigint) по умолчанию;
  - natural key — только если стабилен и есть доменное обоснование.
- FK и политика удаления:
  - по умолчанию `ON DELETE RESTRICT`, `ON UPDATE CASCADE`;
  - `CASCADE` допускается только для служебных зависимостей и фиксируется в карточке объекта.
- Индексы:
  - индексировать все FK;
  - индексировать поля, используемые в фильтрах/сортировках/джойнах по сценариям из `docs/**`.

#### Дополнительные правила для связующих таблиц и 3НФ (MUST)

**Таблицы-связки для M:N:**
- Любая связь M:N реализуется только через отдельную таблицу-связку.
- Имя таблицы-связки формируется как `<left>_<right>`:
  - `<left>` и `<right>` — имена сущностей в нижнем регистре, `snake_case`;
  - порядок имён фиксируется правилом проекта: **по алфавиту** или **по доменному приоритету** (выбрать одно и соблюдать везде).
- В таблице-связке по умолчанию:
  - есть два FK: `<left>_id` и `<right>_id`;
  - PK: составной (`<left>_id`, `<right>_id`) **или** surrogate PK + `UNIQUE(<left>_id, <right>_id)` (выбрать и зафиксировать в `docs/**/обоснование выбора.md`).
- Если у связи есть атрибуты (например `role`, `created_at`), они хранятся в этой таблице-связке, а не в таблицах сущностей.

**Плоская таблица (atomic columns):**
- Таблица хранит атомарные значения: без повторяющихся групп и вложенных структур как основной модели.
- Имена колонок в рамках одной таблицы **уникальны** (без двусмысленностей и дубликатов, включая различия только регистром/пунктуацией).
- Колонки именуются однозначно и самодокументируемо:
  - FK-колонка всегда именуется `<referenced_table_singular>_id`;
  - поля времени: `<action>_at` (`created_at`, `updated_at`, `deleted_at`), если используется стандартный набор.

**Зависимости ключей и атрибутов (3НФ формулировка):**
- Ключевые поля (атрибуты, входящие в кандидатные ключи/уникальные идентификаторы) определяют сущность и выбираются так, чтобы быть:
  - минимальными (без лишних колонок),
  - стабильными (не меняются без необходимости),
  - однозначными.
- Неключевые поля **зависят только от PK** (полная функциональная зависимость от ключа).
- Неключевые поля **не зависят от других неключевых полей** (нет транзитивных зависимостей).
  - Если поле логически выводится из другого неключевого поля — оно не хранится, либо хранится только как денормализация с обоснованием из `docs/**`.

**Практическая проверка на 3НФ (минимум):**
- [ ] для каждой таблицы указаны кандидатные ключи/PK и объяснено, почему выбран именно он
- [ ] каждый неключевой атрибут отвечает на вопрос "это свойство этой сущности?" и "зависит ли оно только от PK?"
- [ ] справочники/перечни/повторяющиеся атрибуты вынесены в отдельные таблицы
- [ ] для M:N всегда есть таблица-связка по правилам выше

### 2.5.2 document — управление денормализацией (MUST)
Если выбран `document` и нет отдельной методологии:

- Единица хранения: документ, сгруппированный по границе агрегата (bounded context).
- В документе допускается денормализация внутри агрегата; межагрегатные связи — через ссылки/идентификаторы.
- Обязательны правила валидации (JSON Schema/validator) для ключевых коллекций.
- Обязательны индексы под ключевые запросы; состав индексов фиксируется в карточке коллекции.
- Большие бинарные/файловые поля в документе запрещены, если есть object-storage; хранить ссылку + метаданные.
- Версионирование схемы:
  - фиксировать `schemaVersion` (или эквивалент) в документе, если ожидаются изменения структуры.
- TTL/retention:
  - явно задавать для временных/сырьевых коллекций, если есть требования жизненного цикла данных.

### 2.5.3 time-series — неизменяемые события и политика хранения (MUST)
Если выбран `time-series` и нет отдельной методологии:

- Единица хранения: временная серия/измерение (measurement).
- Записи временных рядов считаются append-only; обновления допускаются только при явном обосновании.
- Обязательно определить:
  - ключ серии (tags/labels),
  - поле времени,
  - retention,
  - агрегирование/downsampling (если требуется аналитикой/стоимостью).
- Партиционирование по времени:
  - включать по умолчанию при ожидаемом росте (указать критерий объёма/скорости).
- Индексация:
  - ключ серии + время должны обеспечивать быстрый диапазонный запрос.
- Идемпотентность:
  - если есть риск дублей — фиксировать ключ идемпотентности и правило дедупликации.

### 2.5.4 kv — контракт ключей и TTL (MUST)
Если выбран `kv` и нет отдельной методологии:

- Единица хранения: namespace + формат ключа.
- Обязателен контракт ключей:
  - шаблон ключа (включая tenant/user),
  - версия ключа (если планируются изменения),
  - тип и сериализация значения.
- По умолчанию все ключи имеют TTL, если не указано иное (избежать "вечного" мусора).
- Консистентность и атомарность:
  - указать, какие операции атомарны (setnx, compare-and-set, транзакции/скрипты), и где это требуется.
- Кэш vs источник истины:
  - KV по умолчанию НЕ является source of truth; если является — требуется отдельное обоснование в `docs/**`.

### 2.5.5 graph — явная модель типов и ограничений (MUST)
Если выбран `graph` и нет отдельной методологии:

- Единица хранения: node type / edge type.
- Обязательна типизация:
  - список типов узлов и рёбер,
  - обязательные свойства,
  - ограничения (unique/exists) где поддерживается.
- Индексация:
  - индексы на поля, используемые в стартовых точках и фильтрах.
- Запросные паттерны:
  - минимум 3 ключевых паттерна (traversal) с оценкой ожидаемой глубины/стоимости.
- Данные высокого объёма (логи/телеметрия) не хранить в графе без отдельного обоснования.

### 2.5.6 object-storage — метаданные отдельно, жизненный цикл обязателен (MUST)
Если выбран `object-storage` и нет отдельной методологии:

- Единица хранения: bucket + object key.
- Обязательно определить:
  - схему ключей (включая tenant/user),
  - набор метаданных (content-type, size, checksum, created_at, owner),
  - lifecycle/retention (удаление/архивирование).
- В БД хранить только ссылку + метаданные; сами бинарные данные в object storage.
- Консистентность:
  - описать правило "сначала объект, потом запись" или наоборот + механизм компенсации.

### 2.5.7 event-log/stream — схема сообщений и совместимость (MUST)
Если выбран `event-log/stream` и нет отдельной методологии:

- Единица хранения: topic/stream + schema.
- Обязательны:
  - схема сообщения (поля/типы),
  - версия схемы и правило совместимости (backward/forward/full),
  - ключ партиционирования (если есть),
  - retention.
- События по умолчанию неизменяемые; коррекция — через новые события (compensating events), если не оговорено иное.
- Трассируемость:
  - каждый event должен иметь correlationId/causationId (или эквивалент), если есть цепочки обработки.

### 2.5.8 hybrid — карта распределения данных обязательна (MUST)
Если выбран `hybrid`:

- Обязательна карта хранилищ (раздел 4.2) и правило "что где хранится" (в 1–2 строках на Store ID).
- Для каждого Store ID применяются правила соответствующего типа (2.5.1–2.5.7).
- Дублирование данных между хранилищами допускается только при:
  - явном описании источника истины,
  - механизма синхронизации,
  - и ссылке на `docs/**`.

---

## 3. Ожидаемый результат (выходные артефакты)

### 3.1 Минимум (обязателен)

Финальные артефакты публикуются в `docs/requirements/структура Данных/**`.

1. `docs/requirements/структура Данных/описание БД.md` — финальная спецификация  
   Содержит:
   * обзор (раздел 4),
   * перечень объектов данных,
   * ссылки на `docs/**`,
   * статус и чеклист валидации,
   * для `hybrid` — карту хранилищ (раздел 4.2),
   * **диаграммы (раздел 4.4) — MUST**.

2. Детальные спецификации объектов данных (1 файл на объект хранения), публикуются в `docs/requirements/структура Данных/`:

- relational: `tables/<object>.md`
- document: `collections/<object>.md`
- time-series: `series/<object>.md` (или `tables/**`)
- kv: `kv/<namespace>.md`
- graph: `graph/<model>.md`
- object-storage: `object_storage/<bucket>.md`
- event-log/stream: `streams/<topic>.md`

3. **Диаграммы (обязательны):**
- `docs/requirements/структура Данных/diagram.mmd` **или** `docs/requirements/структура Данных/diagram.plantuml` — обязательно ровно один файл.
- Если используется `relational` — дополнительно **обязателен** `docs/requirements/структура Данных/tables/erd.dbml` (скрипт для https://dbdiagram.io).

### 3.2 Дополнительно

4. `docs/requirements/структура Данных/validation-report.md` (если есть расхождения)  
   Содержит:
- расхождения: требования vs код/миграции/схема,
- ссылки на `.tasks/<id>`.

---

## 4. Структура финальной спецификации (`docs/requirements/структура Данных/описание БД.md`)

### 4.1 Общая информация

* модель(и) хранилища: `<...>`
* единица описания: `<...>`
* технология/версия (если известно): `<...>`
* имя БД / схемы / неймспейсы: `<...>`
* назначение: `<1–2 строки>`
* формат диаграмм: `<mermaid|plantuml>`
* основание выбора: `<docs/**/обоснование выбора.md#... | draft:.requirements/... + .tasks/<id>>`
* источники требований: список ссылок на `docs/**`
* источники проверки: пути к миграциям/моделям/DDL/валидациям

### 4.2 Карта хранилищ (если несколько или hybrid)

| Store ID | Тип | Назначение | Владелец (сервис/модуль) | Источники `docs/**` | Источники проверки |
|---|---|---|---|---|---|
| DB-01 | relational | … | … | … | … |

### 4.3 Перечень объектов данных

| Объект | Тип | Где хранится (Store ID) | Файл спецификации | Источники `docs/**` |
|---|---|---|---|---|
| `users` | table | DB-01 | `tables/users.md` | `docs/...` |

### 4.4 Диаграммы (MUST)

#### 4.4.1 Единая диаграмма данных (обязательная)

Обязателен один файл (в зависимости от выбранного формата):
- `docs/requirements/структура Данных/diagram.mmd` или
- `docs/requirements/структура Данных/diagram.plantuml`

Содержание (минимум):
- узлы: хранилища (Store ID) и/или логические домены (если важно),
- связи: основные потоки данных и ключевые зависимости,
- если `hybrid` — показать распределение по типам хранилищ.

#### 4.4.2 Relational: скрипт для dbdiagram.io (MUST, если есть relational)

Если используется `relational`:
- `docs/requirements/структура Данных/tables/erd.dbml` обязателен.

Требования к `erd.dbml`:
- отражает актуальные таблицы и связи (FK),
- имена и типы полей согласованы с `tables/*.md`,
- в начале файла комментариями указать источники проверки (DDL/миграции/схема),
- если файл неполный — `status: draft` + `.tasks/<id>`.

---

## 5. Шаблон детальной спецификации объекта  
(для `docs/requirements/структура Данных/<type-dir>/<object>.md`)

### 5.1 Общая карточка (всегда)

#### `<object_name>`

* тип: `<table|collection|series|kv-namespace|node/edge|bucket|topic|view>`
* назначение: `<1–2 строки>`
* владелец: `<сервис/модуль>`
* источники `docs/**`: `<docs/...#...>`
* источники проверки: `<path|command>`
* статус: `<draft|verified>`, ревью: `<кто/когда/PR>`

### 5.2 Структура (выбрать по типу)

#### relational (таблица/представление)

| Поле | Тип | PK | FK | Null | Default | Ограничения | Примечание |
|---|---|---:|---|---:|---|---|---|

Ключи/связи:
* PK: `<...>`
* FK: `<from>.<field> → <to>.<field>` (policy `ON UPDATE/DELETE`: `<...>` с ссылкой на `docs/**/обоснование выбора.md`)

Индексы/ограничения:
* индексы: `<...>`
* unique/check: `<...>`

#### document (коллекция)

| Поле | Тип | Обяз. | Индекс | Валидация | Примечание |
|---|---|---:|---:|---|---|

Правила:
* validation/JSON Schema: `<...>`
* индексы: `<...>`
* примеры документов: `<1–3 примера (кратко)>`

#### time-series

| Поле | Тип | Обяз. | Индекс | Примечание |
|---|---|---:|---:|---|

Политики:
* партиционирование/шардирование: `<...>`
* retention: `<...>` (основание: `docs/**`)
* downsampling/агрегаты: `<...>`

#### kv

Схема:
* namespace: `<...>`
* формат ключа: `<...>`
* значения: `<формат/сериализация>`
* TTL/retention: `<...>`
* атомарные операции/консистентность: `<...>`

#### graph

Модель:
* node types: `<...>`
* edge types: `<...>`
* свойства: `<...>`
* индексы/constraints: `<...>`
* паттерны запросов: `<...>`

#### object-storage

Схема:
* bucket: `<...>`
* объект/ключ: `<формат>`
* метаданные: `<набор полей>`
* lifecycle/retention: `<...>`
* доступ: `<ACL/политики>`

#### event-log/stream

Схема:
* topic: `<...>`
* схема сообщения: `<поля/типы/версия>`
* совместимость: `<backward/forward/full>`
* партиции/ключ: `<...>`
* retention: `<...>`

### 5.3 Использование (всегда)

* сценарии/операции: `<пункты + ссылки на docs/**>`
* критичные запросы/агрегации/чтения: `<минимум 1–3>`
* требования по SLA/целостности/безопасности: `<ссылки на docs/**>`

### 5.4 Примечания (всегда)

* денормализация/дублирование: `<если есть — почему + ссылка>`
* риски роста/блокировок/ретенции: `<кратко>`
* совместимость изменений (если важно): `<кратко>`

---

## 6. Порядок подготовки и обновления спецификации

1. Зафиксировать модель(и) и основание (раздел 2.1).
2. Указать формат диаграмм (раздел 2.4).
3. Сформировать перечень объектов данных (раздел 4.3).
4. Создать/обновить детальные спецификации объектов (раздел 5).
5. Подготовить обязательную диаграмму:
   - `diagram.mmd` или `diagram.plantuml` (по формату проекта),
   - если используется `relational` — также `tables/erd.dbml` для dbdiagram.io.
6. Проставить ссылки на требования/сценарии/обоснование (`docs/**`) и источники проверки (код).
7. Выполнить валидацию (раздел 7).
8. Если обнаружены расхождения — оформить `validation-report.md` и создать `.tasks/<id>`.

---

## 7. Проверка / валидация

Чеклист:

* [ ] перечислены все объекты, упомянутые в `docs/**`
* [ ] для каждого объекта есть детальный файл спецификации
* [ ] связи/зависимости/индексация описаны в форме, соответствующей модели хранения
* [ ] ссылки на требования/решения ведут в `docs/**`
* [ ] источники проверки (код/артефакты) указаны и воспроизводимы
* [ ] присутствует обязательная диаграмма: `diagram.mmd` или `diagram.plantuml`
* [ ] если используется `relational` — присутствует `tables/erd.dbml` (dbdiagram.io)
* [ ] диаграммы согласованы с перечнем объектов и карточками `tables/**`/`collections/**`/etc.
* [ ] расхождения зафиксированы в `validation-report.md` и `.tasks/<id>` (если есть)
* [ ] ревью зафиксировано

---

## 8. Правила ссылок

* Требования/сценарии/обоснования: только `docs/**`.
* Любое существенное решение по структуре (FK policy, денормализация, retention/TTL, модель консистентности) должно иметь ссылку на `docs/**` и при необходимости на `.tasks/<id>`.

### 8.1 Жёсткие правила формата ссылок (MUST)

* Запрещены относительные ссылки: `../`, `./`, а также ссылки без префикса `docs/`.
* Каждая ссылка на требования/сценарии/обоснования **должна начинаться** с `docs/`.
  Пример: `docs/requirements/требования/nfr.md#NFR-PERF-01`.

---

## 9. Организация файлов

* финальные артефакты: `docs/requirements/структура Данных/**`:
  * `описание БД.md`
  * диаграмма: `diagram.mmd` или `diagram.plantuml`
  * для relational: `tables/erd.dbml`
  * подпапки по типу: `tables/`, `collections/`, `series/`, `kv/`, `graph/`, `object_storage/`, `streams/`
  * `validation-report.md` (при необходимости)

---

## 10. Режим теста (используется только если указан в задании)

### 10.1 Ограничение состава вывода (MUST)

Если в задании явно указан «режим теста» и перечислены обязательные артефакты/объекты:

* Вывести **ровно** те документы и карточки объектов, которые перечислены в задании.
* Запрещено добавлять дополнительные объекты данных, дополнительные артефакты и дополнительные файлы спецификаций.
* Разрешено добавить только блок `Открытые вопросы` (не более 5 пунктов) без создания новых объектов/файлов.

### 10.2 Специальное правило для KV/Redis в режиме теста (MUST)

Если в задании сказано «KV/Redis без отдельной карточки»:

* KV/Redis описывается только:
  - в карте хранилищ (раздел 4.2),
  - и кратко в соответствующих местах (TTL/ключи/идемпотентность).
* Запрещено выводить отдельные карточки вида `kv/**` и запрещено добавлять `kv/**` в список выходных артефактов.
