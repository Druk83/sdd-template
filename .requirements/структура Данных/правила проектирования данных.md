# Правила проектирования данных по умолчанию

> **Важно:** этот файл в `.requirements/**` — **методика** (read-only).
> Применяется, если в `docs/**/обоснование выбора.md` не задано иное.
> Любое отклонение от правил должно иметь ссылку на `docs/**` и (при необходимости) `.tasks/<id>`.

---

## 1. relational (OLTP) — 3НФ по умолчанию (MUST)

Если выбран `relational` и нет отдельной методологии в `docs/**/обоснование выбора.md`, то логическая модель проектируется в 3НФ:

- 1 сущность = 1 таблица. Смешивание разных сущностей в одной таблице запрещено.
- Каждый неключевой атрибут зависит только от PK и не зависит транзитивно от других неключевых атрибутов.
- M:N связи реализуются только через таблицу-связку.
- Повторяющиеся группы/массивы в колонках запрещены; для множественных значений — отдельная таблица/связка.
- Справочники/enum-значения, используемые в нескольких местах или подлежащие изменению, выносятся в отдельные таблицы.
- Денормализация (дублирование данных, предвычисленные поля, wide tables) запрещена без требования производительности и обоснования в `docs/**`.
- JSON/ARRAY допускаются только как "контейнер вторичных атрибутов" при явном обосновании; основная доменная модель — через связи.
- PK:
  - допускается surrogate (uuid/bigint) по умолчанию;
  - natural key — только если стабилен и есть доменное обоснование.
- FK и политика удаления:
  - по умолчанию `ON DELETE RESTRICT`, `ON UPDATE CASCADE`;
  - `CASCADE` допускается только для служебных зависимостей и фиксируется в карточке объекта.
- Индексы:
  - индексировать все FK;
  - индексировать поля, используемые в фильтрах/сортировках/джойнах по сценариям из `docs/**`.

### 1.1 Дополнительные правила для связующих таблиц и 3НФ (MUST)

**Таблицы-связки для M:N:**
- Любая связь M:N реализуется только через отдельную таблицу-связку.
- Имя таблицы-связки формируется как `<left>_<right>`:
  - `<left>` и `<right>` — имена сущностей в нижнем регистре, `snake_case`;
  - порядок имён фиксируется правилом проекта: **по алфавиту** или **по доменному приоритету** (выбрать одно и соблюдать везде).
- В таблице-связке по умолчанию:
  - есть два FK: `<left>_id` и `<right>_id`;
  - PK: составной (`<left>_id`, `<right>_id`) **или** surrogate PK + `UNIQUE(<left>_id, <right>_id)` (выбрать и зафиксировать в `docs/**/обоснование выбора.md`).
- Если у связи есть атрибуты (например `role`, `created_at`), они хранятся в этой таблице-связке, а не в таблицах сущностей.

**Плоская таблица (atomic columns):**
- Таблица хранит атомарные значения: без повторяющихся групп и вложенных структур как основной модели.
- Имена колонок в рамках одной таблицы **уникальны** (без двусмысленностей и дубликатов, включая различия только регистром/пунктуацией).
- Колонки именуются однозначно и самодокументируемо:
  - FK-колонка всегда именуется `<referenced_table_singular>_id`;
  - поля времени: `<action>_at` (`created_at`, `updated_at`, `deleted_at`), если используется стандартный набор.

**Зависимости ключей и атрибутов (3НФ формулировка):**
- Ключевые поля (атрибуты, входящие в кандидатные ключи/уникальные идентификаторы) определяют сущность и выбираются так, чтобы быть:
  - минимальными (без лишних колонок),
  - стабильными (не меняются без необходимости),
  - однозначными.
- Неключевые поля **зависят только от PK** (полная функциональная зависимость от ключа).
- Неключевые поля **не зависят от других неключевых полей** (нет транзитивных зависимостей).
  - Если поле логически выводится из другого неключевого поля — оно не хранится, либо хранится только как денормализация с обоснованием из `docs/**`.

**Практическая проверка на 3НФ (минимум):**
- [ ] для каждой таблицы указаны кандидатные ключи/PK и объяснено, почему выбран именно он
- [ ] каждый неключевой атрибут отвечает на вопрос "это свойство этой сущности?" и "зависит ли оно только от PK?"
- [ ] справочники/перечни/повторяющиеся атрибуты вынесены в отдельные таблицы
- [ ] для M:N всегда есть таблица-связка по правилам выше

---

## 2. document — управление денормализацией (MUST)

Если выбран `document` и нет отдельной методологии:

- Единица хранения: документ, сгруппированный по границе агрегата (bounded context).
- В документе допускается денормализация внутри агрегата; межагрегатные связи — через ссылки/идентификаторы.
- Обязательны правила валидации (JSON Schema/validator) для ключевых коллекций.
- Обязательны индексы под ключевые запросы; состав индексов фиксируется в карточке коллекции.
- Большие бинарные/файловые поля в документе запрещены, если есть object-storage; хранить ссылку + метаданные.
- Версионирование схемы:
  - фиксировать `schemaVersion` (или эквивалент) в документе, если ожидаются изменения структуры.
- TTL/retention:
  - явно задавать для временных/сырьевых коллекций, если есть требования жизненного цикла данных.

---

## 3. time-series — неизменяемые события и политика хранения (MUST)

Если выбран `time-series` и нет отдельной методологии:

- Единица хранения: временная серия/измерение (measurement).
- Записи временных рядов считаются append-only; обновления допускаются только при явном обосновании.
- Обязательно определить:
  - ключ серии (tags/labels),
  - поле времени,
  - retention,
  - агрегирование/downsampling (если требуется аналитикой/стоимостью).
- Партиционирование по времени:
  - включать по умолчанию при ожидаемом росте (указать критерий объёма/скорости).
- Индексация:
  - ключ серии + время должны обеспечивать быстрый диапазонный запрос.
- Идемпотентность:
  - если есть риск дублей — фиксировать ключ идемпотентности и правило дедупликации.

---

## 4. kv — контракт ключей и TTL (MUST)

Если выбран `kv` и нет отдельной методологии:

- Единица хранения: namespace + формат ключа.
- Обязателен контракт ключей:
  - шаблон ключа (включая tenant/user),
  - версия ключа (если планируются изменения),
  - тип и сериализация значения.
- По умолчанию все ключи имеют TTL, если не указано иное (избежать "вечного" мусора).
- Консистентность и атомарность:
  - указать, какие операции атомарны (setnx, compare-and-set, транзакции/скрипты), и где это требуется.
- Кэш vs источник истины:
  - KV по умолчанию НЕ является source of truth; если является — требуется отдельное обоснование в `docs/**`.

---

## 5. graph — явная модель типов и ограничений (MUST)

Если выбран `graph` и нет отдельной методологии:

- Единица хранения: node type / edge type.
- Обязательна типизация:
  - список типов узлов и рёбер,
  - обязательные свойства,
  - ограничения (unique/exists) где поддерживается.
- Индексация:
  - индексы на поля, используемые в стартовых точках и фильтрах.
- Запросные паттерны:
  - минимум 3 ключевых паттерна (traversal) с оценкой ожидаемой глубины/стоимости.
- Данные высокого объёма (логи/телеметрия) не хранить в графе без отдельного обоснования.

---

## 6. object-storage — метаданные отдельно, жизненный цикл обязателен (MUST)

Если выбран `object-storage` и нет отдельной методологии:

- Единица хранения: bucket + object key.
- Обязательно определить:
  - схему ключей (включая tenant/user),
  - набор метаданных (content-type, size, checksum, created_at, owner),
  - lifecycle/retention (удаление/архивирование).
- В БД хранить только ссылку + метаданные; сами бинарные данные в object storage.
- Консистентность:
  - описать правило "сначала объект, потом запись" или наоборот + механизм компенсации.

---

## 7. event-log/stream — схема сообщений и совместимость (MUST)

Если выбран `event-log/stream` и нет отдельной методологии:

- Единица хранения: topic/stream + schema.
- Обязательны:
  - схема сообщения (поля/типы),
  - версия схемы и правило совместимости (backward/forward/full),
  - ключ партиционирования (если есть),
  - retention.
- События по умолчанию неизменяемые; коррекция — через новые события (compensating events), если не оговорено иное.
- Трассируемость:
  - каждый event должен иметь correlationId/causationId (или эквивалент), если есть цепочки обработки.

---

## 8. hybrid — карта распределения данных обязательна (MUST)

Если выбран `hybrid`:

- Обязательна карта хранилищ и правило "что где хранится" (в 1-2 строках на Store ID).
- Для каждого Store ID применяются правила соответствующего типа (разделы 1-7).
- Дублирование данных между хранилищами допускается только при:
  - явном описании источника истины,
  - механизма синхронизации,
  - и ссылке на `docs/**`.
